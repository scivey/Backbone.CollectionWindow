// Generated by CoffeeScript 1.6.3
(function() {
  var Backbone, CollectionWindow, NumCollection, NumModel, arrayEq, asKey, assert, equivSlice, extractVal, extractVals, flatsplat, nRandomInts, numsToCollection, numsToValues, path, randomInt, sliceVals, _,
    __slice = [].slice;

  _ = require("underscore");

  Backbone = require("backbone");

  path = require("path");

  assert = require("better-assert");

  CollectionWindow = require("../index.js").CollectionWindow;

  NumModel = Backbone.Model.extend({
    defaults: {
      value: 0
    }
  });

  NumCollection = Backbone.Collection.extend({
    model: NumModel
  });

  flatsplat = function(list) {
    if (list.length === 1 && _.isArray(list[0])) {
      return list[0];
    } else {
      return list;
    }
  };

  asKey = function(keyName) {
    return function(val) {
      var _o;
      _o = {};
      _o[keyName] = val;
      return _o;
    };
  };

  numsToValues = function() {
    var numList, _o;
    numList = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    numList = flatsplat(numList);
    _o = _.map(numList, asKey("value"));
    return _o;
  };

  numsToCollection = function() {
    var numList, _coll, _vals;
    numList = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    numList = flatsplat(numList);
    _vals = numsToValues(numList);
    return _coll = new NumCollection(_vals);
  };

  randomInt = function(min, max) {
    var _n, _range;
    if (max == null) {
      max = min;
      min = 0;
    }
    _range = max - min;
    _n = Math.random() * _range;
    _n = Math.floor(_n) + min;
    return _n;
  };

  extractVal = function(model) {
    var _json;
    _json = model.toJSON();
    return _json.value;
  };

  extractVals = function(modelList) {
    var _vals;
    _vals = _.map(modelList, extractVal);
    return _vals;
  };

  nRandomInts = function(n, min, max) {
    var _o;
    _o = [];
    if (max == null) {
      max = min;
      min = 0;
    }
    while (n--) {
      _o.push(randomInt(min, max));
    }
    return _o;
  };

  arrayEq = function(a, b) {
    var both, _cmp, _result;
    both = _.zip(a, b);
    _cmp = function(pair) {
      return pair[0] === pair[1];
    };
    _result = _.every(both, _cmp);
    return _result;
  };

  sliceVals = function(collRef, start, end) {
    var _models;
    if (end == null) {
      end = collRef.length;
    }
    _models = collRef.slice(start, end);
    return extractVals(_models);
  };

  equivSlice = function(coll, collWindow) {
    var _equiv, _r;
    _r = collWindow._getRange();
    _equiv = sliceVals(coll, _r[0], _r[1]);
    return _equiv;
  };

  describe("CollectionWindow", function() {
    var coll, collWin, _nums, _opts;
    _nums = nRandomInts(10, 100, 200);
    coll = numsToCollection(_nums);
    _opts = {
      start: 0,
      size: 3
    };
    collWin = new CollectionWindow(coll, _opts);
    beforeEach(function() {
      return collWin = new CollectionWindow(coll, _opts);
    });
    it("contains `options.size` models.", function() {
      var _o, _size2;
      _o = collWin.map(extractVal);
      assert(_o.length === _opts.size);
      _size2 = 6;
      collWin = new CollectionWindow(coll, {
        start: 1,
        size: _size2
      });
      _o = collWin.map(extractVal);
      return assert(_o.length === _size2);
    });
    it("begins at index `options.start`.", function() {
      var _i, _i2;
      _i = _opts.start;
      assert(collWin.at(0) === coll.at(_i));
      _i2 = 3;
      collWin = new CollectionWindow(coll, {
        start: _i2,
        size: 4
      });
      return assert(collWin.at(0) === coll.at(_i2));
    });
    it("is equal to the equivalent slice from the parent collection.", function() {
      var _equiv, _vals;
      _vals = collWin.map(extractVal);
      _equiv = equivSlice(coll, collWin);
      assert(arrayEq(_vals, _equiv));
      collWin = new CollectionWindow(coll, {
        start: 3,
        size: 5
      });
      _vals = collWin.map(extractVal);
      _equiv = equivSlice(coll, collWin);
      return assert(arrayEq(_vals, _equiv));
    });
    describe("#goForward", function() {
      it("advances by one when called without arguments.", function() {
        var newRange, origRange, _all, _forwarded, _vals;
        origRange = collWin._getRange();
        collWin.goForward();
        newRange = collWin._getRange();
        assert(newRange[0] === (origRange[0] + 1));
        assert(newRange[1] === (origRange[1] + 1));
        _all = sliceVals(coll, origRange[0], newRange[1]);
        _forwarded = _all.slice(1);
        _vals = collWin.map(extractVal);
        return assert(arrayEq(_forwarded, _vals));
      });
      it("advances by `n` when called with int argument `n`.", function() {
        var newRange, origRange, _all, _forwarded, _n, _vals;
        origRange = collWin._getRange();
        _n = 3;
        collWin.goForward(_n);
        newRange = collWin._getRange();
        assert(newRange[0] === (origRange[0] + _n));
        assert(newRange[1] === (origRange[1] + _n));
        _all = sliceVals(coll, origRange[0], newRange[1]);
        _forwarded = _all.slice(3);
        _vals = collWin.map(extractVal);
        return assert(arrayEq(_forwarded, _vals));
      });
      it("does not advance beyond the end of the parent collection.", function() {
        var collSize, expectedRange, newRange, origRange, winSize, _expectedVals, _n, _vals;
        collSize = coll.length;
        winSize = _opts.size;
        _n = collSize;
        origRange = collWin._getRange();
        expectedRange = [collSize - winSize, collSize];
        collWin.goForward(_n);
        newRange = collWin._getRange();
        assert(newRange[0] === expectedRange[0]);
        assert(newRange[1] === expectedRange[1]);
        _expectedVals = sliceVals(coll, expectedRange[0], expectedRange[1]);
        _vals = collWin.map(extractVal);
        return assert(arrayEq(_expectedVals, _vals));
      });
      it("returns true if advancement occurs", function() {
        assert(collWin.goForward());
        return assert(collWin.goForward(2));
      });
      return it("returns false if already at the last possible window of the parent", function() {
        var collSize, winSize, _n, _res1, _res2, _res3;
        collSize = coll.length;
        winSize = _opts.size;
        _n = collSize;
        _res1 = collWin.goForward(_n);
        assert(_res1);
        _res2 = collWin.goForward();
        assert(_res2 === false);
        _res3 = collWin.goForward(3);
        return assert(_res3 === false);
      });
    });
    return describe("#goBack", function() {
      it("goes back by one when called without arguments.", function() {
        var newRange, origRange, _backed, _size, _start, _v, _vals;
        _size = 4;
        _start = 3;
        collWin = new CollectionWindow(coll, {
          start: _start,
          size: _size
        });
        _v = collWin.map(extractVal);
        origRange = collWin._getRange();
        collWin.goBack();
        newRange = collWin._getRange();
        assert(newRange[0] === (origRange[0] - 1));
        assert(newRange[1] === (origRange[1] - 1));
        _backed = sliceVals(coll, newRange[0], newRange[1]);
        _vals = collWin.map(extractVal);
        return assert(arrayEq(_backed, _vals));
      });
      it("goes back by `n` when called with int argument `n`.", function() {
        var newRange, origRange, _all, _backed, _n, _size, _start, _v, _vals;
        _size = 3;
        _start = 5;
        collWin = new CollectionWindow(coll, {
          start: _start,
          size: _size
        });
        _v = collWin.map(extractVal);
        _n = 3;
        origRange = collWin._getRange();
        collWin.goBack(_n);
        newRange = collWin._getRange();
        assert(newRange[0] === (origRange[0] - _n));
        assert(newRange[1] === (origRange[1] - _n));
        _backed = sliceVals(coll, newRange[0], newRange[1] + 1);
        _vals = collWin.map(extractVal);
        _all = sliceVals(coll, 0);
        return assert(arrayEq(_backed, _vals));
      });
      it("does not go back beyond the beginning of the parent collection.", function() {
        var collSize, expectedRange, newRange, origRange, winSize, _expectedVals, _n, _vals;
        collSize = coll.length;
        winSize = _opts.size;
        _n = collSize;
        origRange = collWin._getRange();
        expectedRange = [0, winSize];
        collWin.goBack(_n);
        newRange = collWin._getRange();
        assert(newRange[0] === expectedRange[0]);
        assert(newRange[1] === expectedRange[1]);
        _expectedVals = sliceVals(coll, expectedRange[0], expectedRange[1]);
        _vals = collWin.map(extractVal);
        return assert(arrayEq(_expectedVals, _vals));
      });
      it("returns true if the window changes", function() {
        var _size, _start;
        _size = 3;
        _start = 5;
        collWin = new CollectionWindow(coll, {
          start: _start,
          size: _size
        });
        assert(collWin.goBack());
        return assert(collWin.goBack(2));
      });
      return it("returns false if already at the last possible window of the parent", function() {
        var collSize, winSize, _n, _res1, _res2, _res3, _size, _start;
        _size = 3;
        _start = 5;
        collWin = new CollectionWindow(coll, {
          start: _start,
          size: _size
        });
        collSize = coll.length;
        winSize = _opts.size;
        _n = _start;
        _res1 = collWin.goBack(_n);
        assert(_res1);
        _res2 = collWin.goBack();
        assert(_res2 === false);
        _res3 = collWin.goBack(3);
        return assert(_res3 === false);
      });
    });
  });

}).call(this);
